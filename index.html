<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>gBlocks4 - Canvas Static + Color Chase</title>
<style>
body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#000000; }
canvas { display:block; margin:auto; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
const TEXT_COLOR = '#000000';
const BG_COLOR = '#ffffff';
const FONT_FAMILY = 'monospace';
const FONT_SIZE = 72;
const ROWS = 20;
const COLS = 16;
const MESSAGE = "FOMZ likes purple orange blue and pink";
const COLOR1 = '#ff00ff';
const COLOR2 = '#00ffff';
const COLOR3 = '#ffff00';

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let scaledFontSize, scaledLetterSpacing, scaledLineHeight;
let lines = [];
let chars = [];

function buildText() {
    const encoder = new TextEncoder();
    const messageBytes = Array.from(encoder.encode(MESSAGE));
    let messagePos = 0;
    const startRow = 10;
    const generatedLines = [];

    for (let i = 0; i < ROWS; i++) {
        const address = (i * 16).toString(16).padStart(8, '0').toUpperCase();
        let hexPart = '';
        let asciiPart = '';

        for (let j = 0; j < COLS; j++) {
            let byte = Math.floor(Math.random() * 256);
            let asciiChar = '.';

            if (i < 2 || (i === 2 && j < 8)) {
                asciiChar = '.';
            } else if (i >= startRow && messagePos < messageBytes.length) {
                byte = messageBytes[messagePos];
                asciiChar = String.fromCharCode(byte);
                messagePos++;
            } else {
                asciiChar = (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
            }

            const hex = byte.toString(16).padStart(2, '0').toUpperCase();
            hexPart += hex + (j === 7 ? '  ' : ' ');
            asciiPart += asciiChar;
        }

        generatedLines.push(`${address}   ${hexPart} ${asciiPart}`);
    }
    return generatedLines;
}

function setupChars() {
    chars = [];
    ctx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
    const padding = scaledFontSize * 0.8;
    const startX = padding;
    const startY = padding;

    lines.forEach((line, i) => {
        [...line].forEach((char, j) => {
            chars.push({
                char,
                x: startX + j * scaledLetterSpacing,
                y: startY + i * scaledLineHeight,
                chaseColor: null
            });
        });
    });
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.textBaseline = 'top';
    ctx.textAlign = 'left';
    ctx.font = `${scaledFontSize}px ${FONT_FAMILY}`;

    chars.forEach(c => {
        ctx.fillStyle = c.chaseColor || TEXT_COLOR;
        ctx.fillText(c.char, c.x, c.y);
    });

    requestAnimationFrame(render);
}

function startColorChase() {
    const colors = [COLOR1, COLOR2, COLOR3];
    let index = 0;

    setInterval(() => {
        const start = Math.floor(Math.random() * chars.length);
        for (let i = 0; i < chars.length; i++) {
            setTimeout(() => {
                const idx = (start + i) % chars.length;
                chars[idx].chaseColor = colors[(index + i) % colors.length];
                setTimeout(() => {
                    chars[idx].chaseColor = null;
                }, 200);
            }, i * 30);
        }
        index = (index + 1) % colors.length;
    }, 4000);
}

function resizeCanvas() {
    const baseFontSize = FONT_SIZE;
    const baseLetterSpacing = 0.6;
    const baseLineHeight = 1.2;
    const paddingRatio = 0.8;

    const letterWidth = baseFontSize * baseLetterSpacing;
    const lineHeight = baseFontSize * baseLineHeight;
    const textBlockWidth = Math.max(...lines.map(l => l.length)) * letterWidth;
    const textBlockHeight = lines.length * lineHeight;
    const padding = baseFontSize * paddingRatio;
    const blockWidth = textBlockWidth + padding * 2;
    const blockHeight = textBlockHeight + padding * 2;

    const margin = 5;
    const availW = window.innerWidth - margin * 2;
    const availH = window.innerHeight - margin * 2;
    const fitScale = Math.min(availW / blockWidth, availH / blockHeight);
    canvas.style.width = `${blockWidth * fitScale}px`;
    canvas.style.height = `${blockHeight * fitScale}px`;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = blockWidth * dpr;
    canvas.height = blockHeight * dpr;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    scaledFontSize = baseFontSize;
    scaledLetterSpacing = letterWidth;
    scaledLineHeight = lineHeight;
}

function saveCanvasImage() {
    const exportScale = 1;
    const padding = scaledFontSize * 0.8;

    const textWidth = Math.max(...lines.map(l => l.length)) * scaledLetterSpacing;
    const textHeight = lines.length * scaledLineHeight;
    const blockWidth = textWidth + padding * 2;
    const blockHeight = textHeight + padding * 2;

    const dpr = window.devicePixelRatio || 1;
    const pixelBlockWidth = blockWidth * dpr;
    const pixelBlockHeight = blockHeight * dpr;

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = pixelBlockWidth * exportScale;
    tempCanvas.height = pixelBlockHeight * exportScale;
    const tempCtx = tempCanvas.getContext('2d');

    tempCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    tempCtx.fillStyle = BG_COLOR;
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

    tempCtx.fillStyle = TEXT_COLOR;
    tempCtx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
    tempCtx.textBaseline = 'top';
    tempCtx.textAlign = 'left';

    const startX = padding;
    const startY = padding;

    lines.forEach((line, i) => {
        [...line].forEach((char, j) => {
            const x = startX + j * scaledLetterSpacing;
            const y = startY + i * scaledLineHeight;
            tempCtx.fillText(char, x, y);
        });
    });

    const link = document.createElement('a');
    link.href = tempCanvas.toDataURL('image/png');
    link.download = 'gBlocks.png';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// TAP/DOUBLE TAP
(function(){
    let tapCount = 0;
    let tapTimer = null;

    canvas.addEventListener('pointerdown', (e) => {
        tapCount++;
        if (tapTimer) clearTimeout(tapTimer);

        tapTimer = setTimeout(() => {
            if (tapCount === 1) {
                location.reload();
            } else if (tapCount === 2) {
                saveCanvasImage();
            }
            tapCount = 0;
        }, 300);
    });
})();

window.addEventListener('resize', () => {
    lines = buildText();
    resizeCanvas();
    setupChars();
});

lines = buildText();
resizeCanvas();
setupChars();
startColorChase();
render();
</script>

</body>
</html>
