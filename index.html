<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>maybeWorkOn - Canvas Static + Color Chase</title>
<style>
  body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#000000; }
  canvas { display:block; margin:auto; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
// ---- Constants ----
const TEXT_COLOR = '#000000';
const BG_COLOR   = '#000000';
const FONT_FAMILY= 'monospace';
const FONT_SIZE  = 72;
const ROWS       = 20;
const COLS       = 16;
const MESSAGE    = "FOMZ likes purple orange blue and pink";
const COLORS     = ['#ff00ff','#00ffff','#ffff00', '#badeaf', '#ecd3ad'];
const TXT_SV_CLR = '#ffffff';

// ---- Canvas Setup ----
const canvas = document.getElementById('canvas');
const ctx    = canvas.getContext('2d');
let scaledFontSize, scaledLetterSpacing, scaledLineHeight;
let lines = [], chars = [];
let charsPerRow, totalCols;
let snakes = [];

// --------------------
// Layout functions from assetOfish.html
// --------------------
function buildText() {
  const encoder = new TextEncoder();
  const messageBytes = Array.from(encoder.encode(MESSAGE));
  let messagePos = 0;
  const startRow = 10;
  const result = [];

  for (let i = 0; i < ROWS; i++) {
    const address = (i * COLS).toString(16).padStart(8,'0').toUpperCase();
    let hexPart='', asciiPart='';
    for (let j = 0; j < COLS; j++) {
      let byte = Math.floor(Math.random()*256);
      let ch = '.';
      if (i < 2 || (i === 2 && j < 8)) {
        ch = '.';
      } else if (i >= startRow && messagePos < messageBytes.length) {
        byte = messageBytes[messagePos++];
        ch = String.fromCharCode(byte);
      } else {
        ch = (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
      }
      hexPart += byte.toString(16).padStart(2,'0').toUpperCase() + (j === 7 ? '  ' : ' ');
      asciiPart += ch;
    }
    result.push(`${address}   ${hexPart} ${asciiPart}`);
  }
  return result;
}

function setupChars() {
  chars = [];
  ctx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
  const pad = scaledFontSize * 0.8;
  lines.forEach((line, row) => {
    [...line].forEach((c, col) => {
      chars.push({
        char: c,
        x: pad + col * scaledLetterSpacing,
        y: pad + row * scaledLineHeight,
        chaseColor: null
      });
    });
  });
  charsPerRow = lines[0].length;
  totalCols = charsPerRow;
}

function resizeCanvas() {
  const base = FONT_SIZE;
  const letterW = base * 0.6;
  const lineH = base * 1.2;
  const pad = base * 0.8;
  const textW = Math.max(...lines.map(l => l.length)) * letterW;
  const textH = lines.length * lineH;
  const blockW = textW + pad * 2;
  const blockH = textH + pad * 2;
  const margin = 5;
  const scale = Math.min((innerWidth - margin*2) / blockW, (innerHeight - margin*2) / blockH);

  canvas.style.width = `${blockW * scale}px`;
  canvas.style.height = `${blockH * scale}px`;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = blockW * dpr;
  canvas.height = blockH * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  scaledFontSize = base;
  scaledLetterSpacing = letterW;
  scaledLineHeight = lineH;
}

let nextColorIndex = 0;
function pickColor() {
  const c = COLORS[nextColorIndex];
  nextColorIndex = (nextColorIndex + 1) % COLORS.length;
  return c;
}

setInterval(() => {
  for (let i = 0; i < 3; i++) {
    const row   = Math.floor(Math.random() * ROWS);
    const color = pickColor();
    const len   = 2 + Math.random() * 4;    // still small runs
    const spd   = 150 + Math.random() * 100; // a bit faster
    snakes.push(new Snake(row, len, color, spd));
  }
}, 500);


// --------------------
// Snake and render logic unchanged
// --------------------
class Snake {
  constructor(row, length, color, speed) {
    this.row = row;
    this.length = length;
    this.color = color;
    this.shadowColor = this.color;
    this.shadowBlur = 10 + Math.random() * 70;
    this.speed = speed;
    this.headX = 0;
    this.last = performance.now();
  }
  update(now) {
    const dt = (now - this.last) / 500;
    this.headX += dt * this.speed;
    this.last  = now;

    // compute which column the head is on
    const colIdx = Math.floor(this.headX / scaledLetterSpacing);
    // map to the flat chars[] index
    const charIdx = this.row * charsPerRow + colIdx;

    // if in range, stash the blur on that char
    if (charIdx >= 0 && charIdx < chars.length) {
      chars[charIdx].shadowBlur = this.shadowBlur;
    }

    // mark done as before
    if (this.headX > totalCols * scaledLetterSpacing + this.length * scaledLetterSpacing) {
      this.done = true;
    }
  }

  draw() {
    const startIdx = Math.floor((this.headX - this.length * scaledLetterSpacing) / scaledLetterSpacing);
    for (let i = 0; i < this.length; i++) {
      const idx = startIdx + i;
      if (idx >= 0 && idx < charsPerRow) {
        // permanently color this character
        chars[this.row * charsPerRow + idx].chaseColor = this.color;
      }
    }
  }
   }

  function render(now) {
    // clear to background
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // draw every character in its current color (white or taken-over)
    ctx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
    ctx.textBaseline = 'top';
    ctx.textAlign = 'left';
    chars.forEach(c => {
      ctx.save();
      ctx.translate(c.x,c.y);
      // pick the fill color
      ctx.fillStyle = c.chaseColor || TEXT_COLOR;

      // if someone gave this char a shadowBlur, apply it
      if (c.shadowBlur) {
        ctx.shadowColor = c.chaseColor || TEXT_COLOR;
        ctx.shadowBlur  = c.shadowBlur;
      } else {
        ctx.shadowBlur = 0;
      }

      ctx.fillText(c.char, 0, 0);
      ctx.fillText(c.char, 0, 0.5);
      ctx.restore();
    });


  // update & draw snakes
  snakes = snakes.filter(s => {
    s.update(now);
    s.draw(ctx);
    return !s.done;
  });

  // spawn new snake
  if (Math.random() < 0.02) {
    const row = Math.floor(Math.random() * ROWS);
    const color = COLORS[Math.floor(Math.random() * COLORS.length)];
    snakes.push(new Snake(row, 2 + Math.random() * 4, color, 100 + Math.random() * 10));
  }

  requestAnimationFrame(render);
}

// INIT
window.addEventListener('resize', () => {
  lines = buildText();
  resizeCanvas();
  setupChars();
});
lines = buildText();
resizeCanvas();
setupChars();
requestAnimationFrame(render);

function saveCanvasImage() {
    const exportScale = 1;
    const padding = scaledFontSize * 0.8;

    const textWidth = Math.max(...lines.map(l => l.length)) * scaledLetterSpacing;
    const textHeight = lines.length * scaledLineHeight;
    const blockWidth = textWidth + padding * 2;
    const blockHeight = textHeight + padding * 2;

    const dpr = window.devicePixelRatio || 1;
    const pixelBlockWidth = blockWidth * dpr;
    const pixelBlockHeight = blockHeight * dpr;

    // Create a new blank temp canvas
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = pixelBlockWidth * exportScale;
    tempCanvas.height = pixelBlockHeight * exportScale;
    const tempCtx = tempCanvas.getContext('2d');

    // Set high quality rendering
    tempCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Draw clean background
    tempCtx.fillStyle = BG_COLOR;
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

    // Draw original (non-animated) text
    tempCtx.fillStyle = TXT_SV_CLR;
    tempCtx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
    tempCtx.textBaseline = 'top';
    tempCtx.textAlign = 'left';

    const startX = padding;
    const startY = padding;

    lines.forEach((line, i) => {
        [...line].forEach((char, j) => {
            const x = startX + j * scaledLetterSpacing;
            const y = startY + i * scaledLineHeight;
            tempCtx.fillText(char, x, y);
        });
    });

    // Trigger download
    const link = document.createElement('a');
    link.href = tempCanvas.toDataURL('image/png');
    link.download = 'gBlocks.png';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// TAP/DOUBLE TAP
(function(){
    let tapCount = 0;
    let tapTimer = null;

    canvas.addEventListener('pointerdown', (e) => {
        tapCount++;
        if (tapTimer) clearTimeout(tapTimer);

        tapTimer = setTimeout(() => {
            if (tapCount === 1) {
                location.reload();
            } else if (tapCount === 2) {
                saveCanvasImage();
            }
            tapCount = 0;
        }, 300);
    });
})();
</script>

</body>
</html>
