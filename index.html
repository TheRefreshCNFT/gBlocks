<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gBlocks4 - Canvas Fade‑In</title>
  <style>
    body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#000000; }
    canvas { display:block; margin:auto; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); }
  </style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
const TEXT_COLOR   = '#000000';
const BG_COLOR     = '#ffffff';
const FONT_FAMILY  = 'monospace';
const FONT_SIZE    = 72;
const ROWS         = 20;
const COLS         = 16;
const MESSAGE      = "FOMZ likes purple orange blue and pink";

const canvas = document.getElementById('canvas');
const ctx    = canvas.getContext('2d');

let scaledFontSize, scaledLetterSpacing, scaledLineHeight;
let lines = [];
const chars = [];  // { char, x0, y0, delay, dur, start }

// 1) Build the text block exactly as before
function buildText() {
  const encoder      = new TextEncoder();
  const messageBytes = Array.from(encoder.encode(MESSAGE));
  let messagePos     = 0;
  const startRow     = 10;
  const result       = [];

  for (let i = 0; i < ROWS; i++) {
    const address = (i * COLS).toString(16).padStart(8,'0').toUpperCase();
    let hexPart   = '', asciiPart = '';
    for (let j = 0; j < COLS; j++) {
      let byte     = Math.floor(Math.random()*256);
      let ch       = '.';
      if (i < 2 || (i === 2 && j < 8)) {
        ch = '.';
      } else if (i >= startRow && messagePos < messageBytes.length) {
        byte = messageBytes[messagePos++];
        ch   = String.fromCharCode(byte);
      } else {
        ch = (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
      }
      hexPart   += byte.toString(16).padStart(2,'0').toUpperCase() + (j===7?'  ':' ');
      asciiPart += ch;
    }
    result.push(`${address}   ${hexPart} ${asciiPart}`);
  }
  return result;
}

// 2) Measure & scale the canvas exactly as before
function resizeCanvas() {
  const base          = FONT_SIZE;
  const letterW       = base * 0.6;
  const lineH         = base * 1.2;
  const pad           = base * 0.8;
  const textW         = Math.max(...lines.map(l => l.length)) * letterW;
  const textH         = lines.length * lineH;
  const blockW        = textW + pad*2;
  const blockH        = textH + pad*2;
  const margin        = 5;
  const scale         = Math.min((innerWidth-margin*2)/blockW, (innerHeight-margin*2)/blockH);
  canvas.style.width  = `${blockW*scale}px`;
  canvas.style.height = `${blockH*scale}px`;

  const dpr = window.devicePixelRatio || 1;
  canvas.width  = blockW * dpr;
  canvas.height = blockH * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  scaledFontSize      = base;
  scaledLetterSpacing = letterW;
  scaledLineHeight    = lineH;
}

// 3) Prepare each character with its own random fade‑in timing
function setupCharAnims() {
  const pad    = scaledFontSize * 0.8;
  const startX = pad, startY = pad;
  const t0     = performance.now();

  chars.length = 0;
  lines.forEach((line, row) => {
    [...line].forEach((ch, col) => {
      chars.push({
        char:  ch,
        x0:    startX + col * scaledLetterSpacing,
        y0:    startY + row * scaledLineHeight,
        delay: Math.random() * 400,          // 0–400 ms random delay
        dur:   500 + Math.random() * 200,    // 500–700 ms fade duration
        start: t0
      });
    });
  });
}

// 4) Animation: clear → draw background → draw each char at its x0/y0 with alpha
function animateFadeIn(now) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = BG_COLOR;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.font         = `${scaledFontSize}px ${FONT_FAMILY}`;
  ctx.textBaseline = 'top';
  ctx.textAlign    = 'left';

  let allDone = true;
  for (const a of chars) {
    const t = now - a.start;
    if (t < a.delay) {
      allDone = false;
      continue;
    }
    const tt = t - a.delay;
    let alpha;
    if (tt < a.dur) {
      allDone = false;
      alpha = tt / a.dur;
    } else {
      alpha = 1;
    }
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle   = TEXT_COLOR;
    ctx.fillText(a.char, a.x0, a.y0);
    ctx.restore();
  }

  if (!allDone) {
    requestAnimationFrame(animateFadeIn);
  }
}

// 5) Hook it all up on resize & initial load
window.addEventListener('resize', () => {
  lines = buildText();
  resizeCanvas();
  setupCharAnims();
  requestAnimationFrame(animateFadeIn);
});

// first time
lines = buildText();
resizeCanvas();
setupCharAnims();
requestAnimationFrame(animateFadeIn);

function saveCanvasImage() {
    const exportScale = 1;
    const padding = scaledFontSize * 0.8;

    const textWidth = Math.max(...lines.map(l => l.length)) * scaledLetterSpacing;
    const textHeight = lines.length * scaledLineHeight;
    const blockWidth = textWidth + padding * 2;
    const blockHeight = textHeight + padding * 2;

    const dpr = window.devicePixelRatio || 1;
    const pixelBlockWidth = blockWidth * dpr;
    const pixelBlockHeight = blockHeight * dpr;

    // Create a new blank temp canvas
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = pixelBlockWidth * exportScale;
    tempCanvas.height = pixelBlockHeight * exportScale;
    const tempCtx = tempCanvas.getContext('2d');

    // Set high quality rendering
    tempCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Draw clean background
    tempCtx.fillStyle = BG_COLOR;
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

    // Draw original (non-animated) text
    tempCtx.fillStyle = TEXT_COLOR;
    tempCtx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
    tempCtx.textBaseline = 'top';
    tempCtx.textAlign = 'left';

    const startX = padding;
    const startY = padding;

    lines.forEach((line, i) => {
        [...line].forEach((char, j) => {
            const x = startX + j * scaledLetterSpacing;
            const y = startY + i * scaledLineHeight;
            tempCtx.fillText(char, x, y);
        });
    });

    // Trigger download
    const link = document.createElement('a');
    link.href = tempCanvas.toDataURL('image/png');
    link.download = 'gBlocks.png';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// TAP/DOUBLE TAP
(function(){
    let tapCount = 0;
    let tapTimer = null;

    canvas.addEventListener('pointerdown', (e) => {
        tapCount++;
        if (tapTimer) clearTimeout(tapTimer);

        tapTimer = setTimeout(() => {
            if (tapCount === 1) {
                location.reload();
            } else if (tapCount === 2) {
                saveCanvasImage();
            }
            tapCount = 0;
        }, 300);
    });
})();
</script>

</body>
</html>




// INIT
window.addEventListener('resize', () => {
    lines = buildText();
    resizeCanvas();
    drawStaticText();
});

lines = buildText();
resizeCanvas();
drawStaticText();
</script>

</body>
</html>
