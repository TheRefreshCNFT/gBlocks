<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>gBlocks4 - Canvas Static Version</title>
<style>
body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#000000; }
canvas { display:block; margin:auto; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
const TEXT_COLOR = '#000000';
const BG_COLOR = '#ffffff';
const FONT_FAMILY = 'monospace';
const FONT_SIZE = 72;
const ROWS = 20;
const COLS = 16;
const MESSAGE = "FOMZ likes purple orange blue and pink";
const ua = navigator.userAgent || navigator.vendor || window.opera;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let scaledFontSize, scaledLetterSpacing, scaledLineHeight;
let lines = [];

function buildText() {
    const encoder = new TextEncoder();
    const messageBytes = Array.from(encoder.encode(MESSAGE));
    let messagePos = 0;
    const startRow = 10;
    let generatedLines = [];

    for (let i = 0; i < ROWS; i++) {
        const address = (i * 16).toString(16).padStart(8, '0').toUpperCase();
        let hexPart = '';
        let asciiPart = '';

        for (let j = 0; j < COLS; j++) {
            let byte = Math.floor(Math.random() * 256);
            let asciiChar = '.';

            if (i < 2 || (i === 2 && j < 8)) {
                asciiChar = '.';
            } else if (i >= startRow && messagePos < messageBytes.length) {
                byte = messageBytes[messagePos];
                asciiChar = String.fromCharCode(byte);
                messagePos++;
            } else {
                asciiChar = (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
            }

            const hex = byte.toString(16).padStart(2, '0').toUpperCase();
            hexPart += hex + (j === 7 ? '  ' : ' ');
            asciiPart += asciiChar;
        }

        generatedLines.push(`${address}   ${hexPart} ${asciiPart}`);
    }
    return generatedLines;
}

function drawStaticText() {
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = TEXT_COLOR;
    ctx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
    ctx.textBaseline = 'top';
    ctx.textAlign = 'left';

    const padding = scaledFontSize * 0.8;
    const startX = padding;
    const startY = padding;

    lines.forEach((line, i) => {
        [...line].forEach((char, j) => {
            const x = startX + j * scaledLetterSpacing;
            const y = startY + i * scaledLineHeight;
            ctx.fillText(char, x, y);
        });
    });
}

function resizeCanvas() {
    const baseFontSize = FONT_SIZE;
    const baseLetterSpacing = 0.6;
    const baseLineHeight = 1.2;
    const paddingRatio = 0.8;

    const letterWidth = baseFontSize * baseLetterSpacing;
    const lineHeight = baseFontSize * baseLineHeight;
    const textBlockWidth = Math.max(...lines.map(l => l.length)) * letterWidth;
    const textBlockHeight = lines.length * lineHeight;
    const padding = baseFontSize * paddingRatio;
    const blockWidth = textBlockWidth + padding * 2;
    const blockHeight = textBlockHeight + padding * 2;

    const margin = 5;
    const availW = window.innerWidth - margin * 2;
    const availH = window.innerHeight - margin * 2;
    const fitScale = Math.min(availW / blockWidth, availH / blockHeight);
    canvas.style.width = `${blockWidth * fitScale}px`;
    canvas.style.height = `${blockHeight * fitScale}px`;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = blockWidth * dpr;
    canvas.height = blockHeight * dpr;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    scaledFontSize = baseFontSize;
    scaledLetterSpacing = letterWidth;
    scaledLineHeight = lineHeight;
}

const chars = [];        // will hold {char, x0,y0, dx,dy, rot0, delay, dur, fadeDur, start}

function setupCharAnims() {
  const diag = Math.hypot(canvas.width, canvas.height);
  const padding = scaledFontSize * 0.8;
  const startX = padding, startY = padding;

  let t0 = performance.now();
  chars.length = 0;

  lines.forEach((line, row) => {
    [...line].forEach((ch, col) => {
      const x0 = startX + col * scaledLetterSpacing;
      const y0 = startY + row * scaledLineHeight;
      const theta = Math.random() * 2 * Math.PI;
      const d = diag/2 + Math.random()*diag/2;
      const dx = d * Math.cos(theta), dy = d * Math.sin(theta);
      const rot0 = (Math.random()*720 - 360) * Math.PI/180;
      chars.push({
        char: ch,
        x0, y0, dx, dy, rot0,
        delay: Math.random()*400,               // 0–0.4 s
        dur: 900 + Math.random()*200,        // 0.8–1.6 s
        fadeDur: 500,                           // 0.5 s
        start: t0
      });
    });
  });
}

////////////////////////////////////////////////////////
// 2) Cubic‐bezier easing (0.22,1,0.36,1) approximation:
////////////////////////////////////////////////////////
function easeBezier(p) {
  // y‑only, both control‑points have y=1
  // E(p) = 3(1−p)² p ·1 + 3(1−p) p² ·1 + p³
  return 3*(1-p)*(1-p)*p + 3*(1-p)*p*p + p*p*p;
}

////////////////////////////////////////////////////////
// 3) The master animation loop:
////////////////////////////////////////////////////////
function animateFadeIn(now) {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = BG_COLOR;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  let allDone = true;
  chars.forEach(a => {
    const t = now - a.start;
    if (t < a.delay) {
      allDone = false;
      return;    // not yet visible
    }

    const tt = t - a.delay;
    // compute eased progress, but clamp at 1
    const tclamped = Math.min(tt, a.dur);
    const p = tclamped / a.dur;
    const e = easeBezier(p);

    // position, rotation, alpha all track e exactly
    const x     = a.x0 + a.dx * (1 - e);
    const y     = a.y0 + a.dy * (1 - e);
    const rot   = a.rot0 * (1 - e);
    const alpha = e;

    if (tclamped < a.dur) allDone = false;

    // draw this char
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(x, y);
    ctx.rotate(rot);
    ctx.fillStyle = TEXT_COLOR;
    ctx.fillText(a.char, 0, 0);
    ctx.restore();
  });

  if (!allDone) {
    requestAnimationFrame(animateFadeIn);
  }
}
////////////////////////////////////////////////////////
// 4) Kick it all off on load / resize
////////////////////////////////////////////////////////
window.addEventListener('resize', () => {
  lines = buildText();
  resizeCanvas();
  // rebuild chars & start animation
  setupCharAnims();
  requestAnimationFrame(animateFadeIn);
});

// initial launch
lines = buildText();
resizeCanvas();
setupCharAnims();
requestAnimationFrame(animateFadeIn);


function saveCanvasImage() {
    const exportScale = 1;
    const padding = scaledFontSize * 0.8;

    const textWidth = Math.max(...lines.map(l => l.length)) * scaledLetterSpacing;
    const textHeight = lines.length * scaledLineHeight;
    const blockWidth = textWidth + padding * 2;
    const blockHeight = textHeight + padding * 2;

    const dpr = window.devicePixelRatio || 1;
    const pixelBlockWidth = blockWidth * dpr;
    const pixelBlockHeight = blockHeight * dpr;

    // Create a new blank temp canvas
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = pixelBlockWidth * exportScale;
    tempCanvas.height = pixelBlockHeight * exportScale;
    const tempCtx = tempCanvas.getContext('2d');

    // Set high quality rendering
    tempCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Draw clean background
    tempCtx.fillStyle = BG_COLOR;
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

    // Draw original (non-animated) text
    tempCtx.fillStyle = TEXT_COLOR;
    tempCtx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
    tempCtx.textBaseline = 'top';
    tempCtx.textAlign = 'left';

    const startX = padding;
    const startY = padding;

    lines.forEach((line, i) => {
        [...line].forEach((char, j) => {
            const x = startX + j * scaledLetterSpacing;
            const y = startY + i * scaledLineHeight;
            tempCtx.fillText(char, x, y);
        });
    });

    // Trigger download
    const link = document.createElement('a');
    link.href = tempCanvas.toDataURL('image/png');
    link.download = 'gBlocks.png';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// TAP/DOUBLE TAP
(function(){
    let tapCount = 0;
    let tapTimer = null;

    canvas.addEventListener('pointerdown', (e) => {
        tapCount++;
        if (tapTimer) clearTimeout(tapTimer);

        tapTimer = setTimeout(() => {
            if (tapCount === 1) {
                location.reload();
            } else if (tapCount === 2) {
                saveCanvasImage();
            }
            tapCount = 0;
        }, 300);
    });
})();

// INIT
window.addEventListener('resize', () => {
    lines = buildText();
    resizeCanvas();
    drawStaticText();
});

lines = buildText();
resizeCanvas();
drawStaticText();
</script>

</body>
</html>
