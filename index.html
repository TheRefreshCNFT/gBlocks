<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>gBlocks4 - Canvas Animated Version</title>
<style>
body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#000000; }
canvas { display:block; margin:auto; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
const TEXT_COLOR = '#ffffff';
const BG_COLOR = '#000000';
const FONT_FAMILY = 'monospace';
const FONT_SIZE = 72;
const ROWS = 20;
const COLS = 16;
const MESSAGE = "FOMZ likes purple orange blue and pink";

const COLORS = [
  '#ff00ff', '#00ffff', '#ffff00', '#ff6600', '#00ff00', '#ff0033', '#33ccff', '#cc33ff'
];

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.style.touchAction = "manipulation";

let scaledFontSize, scaledLetterSpacing, scaledLineHeight;
let lines = [];
let chars = []; // Track character objects

function buildText() {
    const encoder = new TextEncoder();
    const messageBytes = Array.from(encoder.encode(MESSAGE));
    let messagePos = 0;
    const startRow = 10;
    let generatedLines = [];

    for (let i = 0; i < ROWS; i++) {
        const address = (i * 16).toString(16).padStart(8, '0').toUpperCase();
        let hexPart = '';
        let asciiPart = '';

        for (let j = 0; j < COLS; j++) {
            let byte = Math.floor(Math.random() * 256);
            let asciiChar = '.';

            if (i < 2 || (i === 2 && j < 8)) {
                asciiChar = '.';
            } else if (i >= startRow && messagePos < messageBytes.length) {
                byte = messageBytes[messagePos];
                asciiChar = String.fromCharCode(byte);
                messagePos++;
            } else {
                asciiChar = (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
            }

            const hex = byte.toString(16).padStart(2, '0').toUpperCase();
            hexPart += hex + (j === 7 ? '  ' : ' ');
            asciiPart += asciiChar;
        }

        generatedLines.push(`${address}   ${hexPart} ${asciiPart}`);
    }
    return generatedLines;
}

function setupChars() {
    chars = [];
    ctx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
    const padding = scaledFontSize * 0.8;
    const startX = padding;
    const startY = padding;

    lines.forEach((line, i) => {
        [...line].forEach((char, j) => {
            chars.push({
                char,
                x: startX + j * scaledLetterSpacing,
                y: startY + i * scaledLineHeight,
                color: TEXT_COLOR,
                scale: 1,
                rotation: 0
            });
        });
    });
}

function rF(min,max) {
	  return Math.random() * (max - min) + min;
	}

function animate() {
    // Randomize properties
    chars.forEach(c => {
        const glowColor = COLORS[Math.floor(Math.random() * COLORS.length)];
        c.color = COLORS[Math.floor(Math.random() * COLORS.length)];
        c.shadowColor = glowColor;
        c.shadowBlur = 10 + Math.random() * 70; // 15-25px blur
        c.scale = 1 + Math.random() * 0.25;
        c.rotation = (Math.random() * 20 - 10) * (Math.PI / 180); // degrees to radians
    });

    drawCanvas();
}

function drawCanvas() {
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.textBaseline = 'top';
    ctx.textAlign = 'left';

    chars.forEach(c => {
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.rotate(c.rotation);
        ctx.scale(c.scale, c.scale);
        ctx.shadowColor = c.shadowColor || 'transparent'; // default no-shadow
        ctx.shadowBlur = c.shadowBlur || 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.fillStyle = c.color;
        ctx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
        ctx.fillText(c.char, 0, 0);
        ctx.fillText(c.char, 0.5, 0);
        ctx.restore();
    });
}

// Resize logic
function resizeCanvas() {
    const baseFontSize = FONT_SIZE;
    const baseLetterSpacing = 0.6;
    const baseLineHeight = 1.2;
    const paddingRatio = 0.8;

    const letterWidth = baseFontSize * baseLetterSpacing;
    const lineHeight = baseFontSize * baseLineHeight;
    const textBlockWidth = Math.max(...lines.map(l => l.length)) * letterWidth;
    const textBlockHeight = lines.length * lineHeight;
    const padding = baseFontSize * paddingRatio;
    const blockWidth = textBlockWidth + padding * 2;
    const blockHeight = textBlockHeight + padding * 2;

    const margin = 5;
    const availW = window.innerWidth - margin * 2;
    const availH = window.innerHeight - margin * 2;
    const fitScale = Math.min(availW / blockWidth, availH / blockHeight);
    canvas.style.width = `${blockWidth * fitScale}px`;
    canvas.style.height = `${blockHeight * fitScale}px`;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = blockWidth * dpr;
    canvas.height = blockHeight * dpr;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    scaledFontSize = baseFontSize;
    scaledLetterSpacing = letterWidth;
    scaledLineHeight = lineHeight;
}

// Double tap / single tap (save image or reload)
(function(){
    let tapCount = 0;
    let tapTimer = null;

    canvas.addEventListener('pointerdown', (e) => {
        tapCount++;
        if (tapTimer) clearTimeout(tapTimer);

        tapTimer = setTimeout(() => {
            if (tapCount === 1) {
                location.reload();
            } else if (tapCount === 2) {
                saveCanvasImage();
            }
            tapCount = 0;
        }, 300);
    });
})();

function saveCanvasImage() {
    const exportScale = 1;
    const padding = scaledFontSize * 0.8;

    const textWidth = Math.max(...lines.map(l => l.length)) * scaledLetterSpacing;
    const textHeight = lines.length * scaledLineHeight;
    const blockWidth = textWidth + padding * 2;
    const blockHeight = textHeight + padding * 2;

    const dpr = window.devicePixelRatio || 1;
    const pixelBlockWidth = blockWidth * dpr;
    const pixelBlockHeight = blockHeight * dpr;

    // Create a new blank temp canvas
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = pixelBlockWidth * exportScale;
    tempCanvas.height = pixelBlockHeight * exportScale;
    const tempCtx = tempCanvas.getContext('2d');

    // Set high quality rendering
    tempCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Draw clean background
    tempCtx.fillStyle = BG_COLOR;
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

    // Draw original (non-animated) text
    tempCtx.fillStyle = TEXT_COLOR;
    tempCtx.font = `${scaledFontSize}px ${FONT_FAMILY}`;
    tempCtx.textBaseline = 'top';
    tempCtx.textAlign = 'left';

    const startX = padding;
    const startY = padding;

    lines.forEach((line, i) => {
        [...line].forEach((char, j) => {
            const x = startX + j * scaledLetterSpacing;
            const y = startY + i * scaledLineHeight;
            tempCtx.fillText(char, x, y);
        });
    });

    // Trigger download
    const link = document.createElement('a');
    link.href = tempCanvas.toDataURL('image/png');
    link.download = 'gBlocks.png';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// INIT
window.addEventListener('resize', () => {
    lines = buildText();
    resizeCanvas();
    setupChars();
    drawCanvas();
});

lines = buildText();
resizeCanvas();
setupChars();
drawCanvas();

// Start psychedelic animation every second
setInterval(() => {
    animate();
}, 1000);

</script>

</body>
</html>
